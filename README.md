# Бэкенд для codewars-like приложения

Для работы с функционалом peer-to-peer соединения реализован API на веб сокетах. Для данных о задачах и пользователей используется REST API.

## REST API

### POST /api/user

Создаёт нового пользователя. На вход принимает объект следующего вида:

Формат запроса:
```ts
{
  avatar: string;
  hash: string;
  username: string;
}
```

Возвращает объект следующего вида, где uuid - ID созданного пользователя:

Формат ответа:
```ts
{
  uuid: string;
}
```

### POST /api/auth

Авторизуется с указанным именем пользователя и хэшем пароля.

Формат запроса:
```ts
{
  hash: string;
  username: string;
}
```

Возвращает JWT.

Формат ответа:
```ts
{
  access_token: string;
}
```

### GET /api/auth/user

> Требует авторизации с помощью JWT: заголовок `Authorization` формата `Bearer ${jwt}`.

Возвращает данные авторизованного пользователя.

Формат ответа:
```ts
{
  avatar: string;
  connId: string;
  hash: string;
  username: string;
  uuid: string;
}
```

### PUT /api/auth/user

> Требует авторизации с помощью JWT: заголовок `Authorization` формата `Bearer ${jwt}`.

Обновляет данные пользователя. Все поля запроса необязательны.

Формат запроса:
```ts
{
  avatar?: string;
  connId?: string;
  hash?: string;
  username?: string;
  uuid?: string;
}
```

Формат ответа:
```ts
{
  avatar: string;
  connId: string;
  hash: string;
  username: string;
  uuid: string;
}
```

### GET /api/auth/user/${peerConnUuid}

> Требует авторизации с помощью JWT: заголовок `Authorization` формата `Bearer ${jwt}`.

Возвращает имя и аватар пользователя по идентификатору актуального подключения.

Формат ответа:
```ts
{
  avatar: string;
  username: string;
}
```

### GET /api/tasks

> Требует авторизации с помощью JWT: заголовок `Authorization` формата `Bearer ${jwt}`.

Возвращает список задач. `results` - кейсы, массив пар вида `[string, string]`, где первый элемент - JSON-представление аргументов для кейса, второй - ожидаемый результат.

Формат ответа:
```ts
Array<{
  description: string;
  results: [string, string][];
  title: string;
  uuid: string;
}>
```

### POST /api/tasks

> Требует авторизации с помощью JWT: заголовок `Authorization` формата `Bearer ${jwt}`.

Создаёт новую задачу.

Формат запроса:
```ts
{
  description: string;
  results: [string, string][];
  title: string;
}
```

Формат ответа:
```ts
{
  description: string;
  results: [string, string][];
  title: string;
  uuid: string;
}
```

### GET /api/tasks/${taskUuid}

> Требует авторизации с помощью JWT: заголовок `Authorization` формата `Bearer ${jwt}`.

Возвращает данные задачи по её uuid.

Формат ответа:
```ts
{
  description: string;
  results: [string, string][];
  title: string;
  uuid: string;
}
```

## WS API

Подключение к WS-серверу целесообразно непосредственно при входе в процесс соревнования. Подключение инициирует поиск оппонентов, размещая пользователя в виртуальной очереди к соответствующей задачи.

Т. к. подключения имеют смысл только в контексте конкретной задачи, подключение к WS-серверу необходимо осуществлять в следующем формате:
```ts
const socket = new WebSocket(`ws://example-api-url.com:12345?taskId=${taskUuid}`);
```

Далее, как только в очереди появится ещё один свободный пользователь, ищущий оппонента для той же задачи, пользователи будут соединены. После того, как оба отметят свою готовность, стартует соревнование.

Бэкенд не предоставляет механизма проверки заданий, однако позволяет зафиксировать пользователя как победителя, автоматически отправив сопернику сообщение о поражении.

Полный список доступных сообщений приведён далее.

## Принимаемые сообщения

### ready

> формат: `{ event: 'ready' }`

Позволяет передать противнику сигнал о готовности. Автоматически отправляет противнику аналогичное сообщение.

### retry

> формат: `{ event: 'retry' }`

Если пользователь вышел из соревнования и не находится на текущий момент в очереди, возвращает его в очередь по выбранному заданию.

### push

> формат: `{ event: 'push', data: string }`

Сообщение пользовательского ввода (расчитано на работу с событием input поля ввода кода пользователя). Автоматически отправляет противнику сообщение `pull` вида `{ event: 'push', data: string }`, где `data` - тот же текст, что пользователь прислал в сообщении `push`.

### attempt

> формат: `{ event: 'attempt' }`

Фиксирует попытку выполнения своего кода пользователем. Позволяет вести учет количества попыток для обоих пользователей. Автоматически отправляет противнику аналогичное сообщение.

### win

> формат: `{ event: 'win' }`

Сообщение о победе пользователя. Ничего не производит, только автмоатически отправляет противнику сообщение `lose` вида `{ event: 'lose' }`.

### decline

> формат: `{ event: 'decline' }`

Разрывает соединение с противником, автоматически прекращая соревнование и возвращая противника в очередь к задаче. Не возвращает в очередь самого пользователя (для этого предусмотрено отдельное сообщение `retry`). После обработки провоцирует вызов сообщения `disconnect` противнику.

## Отправляемые сообщения

### connect

> формат: `{ event: 'connect', data: string }`

Сообщение отправляется пользователю при его успешном подключении к шлюзу. В качестве пейлода передаётся `connId` нового подключения.

### disconnect

> формат: `{ event: 'disconnect' }`

Сообщение отправляется противнику при разрыве соединения (по любой причине: намеренное отключение сокета, непреднамеренная потеря соединения, сообщение `decline` от игрока).

### pull

> формат: `{ event: 'pull', data: string }`

Передаёт текущий текст игрока противнику, вызывается отправкой игроком сообещния `push`.

### attempt

> формат: `{ event: 'attempt' }`

Вызывается отправкой пользователем аналогичного сообщения серверу, отправляется противнику. Сигнализирует о попытке выполнения кода, успешной или нет.

### lose

> формат: `{ event: 'lose' }`

Вызывается отправкой пользователем сообщения `win` серверу, отправляется противнику. Сигнализирует о победе пользователя.
